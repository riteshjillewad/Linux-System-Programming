# Signals

<img width="1280" height="720" alt="image" src="https://github.com/user-attachments/assets/35da2ef9-18fd-459c-97db-b465799d6802" />

Signals are a fundamental IPC mechanism in Unix systems, but they're quite different from the mechanisms we've discussed so far. Signals are software interrupts that provide a way to handle asynchronous events.

## What are Signaals?
A signal is a notification sent to a process to inform it that a particular event has occurred. Think of signals like emergency alerts or interrupt notifications - they're asynchronous messages that demand immediate attention, interrupting whatever the process is currently doing. Unlike pipes, message queues, or shared memory which are designed for data transfer, signals are primarily for event notification and process control. They carry very little information - essentially just "this event happened."

## Historical Context
Signals have been part of Unix since the very beginning in the early 1970s. They were one of the first IPC mechanisms, designed to handle exceptional conditions and allow process control. The original signal implementation was simple but had reliability issues. POSIX later standardized a more robust signal API that addressed these problems. <br>
Signals remain fundamental to Unix systems. Every time you press `Ctrl+C` to stop a program, use the kill command, or handle exceptional conditions, you're working with signals.

> Signals are asynchronous IPC mechanisms that are used to notify a process of an event, causing it to interuppt normal execution and invoke a predefined action

One process can (if it has suitable permissions) send a signal to another process. In this use, signals can be employed as a synchronization technique, or even as a primitive form of interprocess communication (IPC). It is also possible for a process to send a signal to itself. However, the usual source of many signals sent to a process is the kernel. Among the types of events that cause the kernel to generate a signal for a process are the following:
- A hardware exception occurred, meaning that the hardware detected a fault condition that was notified to the kernel, which in turn sent a corresponding signal to the process concerned.
  - Examples of hardware exceptions include executing a malformed machine-language instruction, dividing by 0, or refer encing a part of memory that is inaccessible.
- The user typed one of the terminal special characters that generate signals. These characters include the interrupt character (usually Control-C) and the suspend character (usually Control-Z).
- A software event occurred. For example, input became available on a file descriptor, the terminal window was resized, a timer went off, the process’s CPU time limit was exceeded, or a child of this process terminated.

## Characteristics of Signals

#### Asynchronous:
- Signals can arrive at any time, interrupting whatever the process is doing. A signal might arrive in the middle of a system call, during computation, or while the process is sleeping.
 
#### Limited Information:
- Signals carry minimal data—primarily just their type (which signal it is). Modern POSIX signals can carry a small amount of additional data, but traditionally signals are just notifications, not data carriers.

#### Process-Directed:
- Signals are sent to specific processes (or groups of processes) identified by their PIDs.
  
#### Kernel-Mediated:
- The kernel delivers signals. When a process sends a signal, it's actually asking the kernel to deliver the signal to the target process.
  
#### Disruptive:
- Signals interrupt normal program flow. The process must stop what it's doing to handle the signal (or ignore it, or terminate).

## Signal Numbers
* Normally, each signal is defined as unique(small) integer, starting sequentially from 1.
* These integers are defined in `signal.h` with symbolic names of form `SIGXXX`.
* Since actual signal numbers vary across implementations, so "symbolic names are always used/preferred in programs".
* Ex: if user types interrupt character, `SIGINT` (signal no 2) is delivered to the process.

<img width="500" height="500" alt="image" src="https://github.com/user-attachments/assets/bcccaea9-fb0d-4618-a90f-45c26e9dd6b1" />

A signal is said to be generated by some event. Once generated, a signal is later delivered to a process, which then takes some action in response to the signal. Between the time it is generated and the time it is delivered, a signal is said to be pending. Normally, a pending signal is delivered to a process as soon as it is next scheduled to run, or immediately if the process is already running (e.g., if the process sent a signal to itself). Sometimes, however, we need to ensure that a segment of code is not interrupted by the delivery of a signal. To do this, we can add a signal to the process’s signal mask—a set of signals whose delivery is currently blocked. If a signal is generated while it is blocked, it remains pending until it is later unblocked (removed from the signal mask). Various system calls allow a process to add and remove signals from its signal mask.

## Signal Disposition
Once the signals are delivered to the process, one of the following things are done:

### Default Actions
Each signal has a default action defined by the system.
* For most signals, default action is terminate(die immediately).
* For some (`SIGCHILD`), default is ignore.
* For errors (like `SIGSEV`), default is **"Core Dump"**.
A core dump file contains image of virtual memory of the process, which can be loaded into a debugger in order to inspect the state of the process at the time it is terminated.

### Ignore (`SIG_IGN`)
The process can explicitly ignore certain signals. (But `SIGKILL` or `SIGSTOP` cannot be caught or ignored).

### Catch/Handle (Custom Handler)
* Instead of accepting default or particualr signals, a program can change action that occurs when signal is delivered, know as setting the disposition of signal, So we can set a custom "Signal Handler".
* A signal handler is function, written by programmers, that performs appropriate tasks in response to delivery of signal
* So whenever a signal arrives, the main code pauses, CPU jumps to the handler, runs it and then resumes the main code, where it left off. Ex: shell has handler for `SIGINT` signal(generated by interuppt character, `CLTR + C`) that causes it to stop what it is currenlty doing and return control to main input loop, so the user is once more presented with the shell prompt.
* Notifying the kernel that a handler function should be invoked is referred to as "installing or establishing signal handler". So when signal handler is invoked to delivery of signal, we say signal has been handled or caught.

## Common and Important Signals

| Signal     | Signal Number | Meaning / Description                                             | Example / When It Occurs            |
|-----------|---------------|-------------------------------------------------------------------|------------------------------------|
| SIGINT    | 2             | Interrupt signal                                                   | User presses **Ctrl + C**           |
| SIGTERM   | 15            | Termination request (graceful)                                    | Sent by `kill pid`                  |
| SIGKILL   | 9             | Forcefully terminate process (cannot be caught or ignored)        | `kill -9 pid`                       |
| SIGSTOP   | 19            | Stop (pause) process execution (cannot be caught)                 | `kill -STOP pid`                    |
| SIGCONT   | 18            | Continue a stopped process                                        | `kill -CONT pid`                    |
| SIGSEGV   | 11            | Segmentation fault                                                 | Invalid memory access               |
| SIGABRT   | 6             | Abnormal termination                                              | `abort()` called                    |
| SIGFPE    | 8             | Floating point exception                                          | Divide by zero                      |
| SIGILL    | 4             | Illegal instruction                                               | Invalid CPU instruction             |
| SIGCHLD   | 17            | Child process terminated or stopped                               | Child exits                         |
| SIGALRM   | 14            | Alarm signal                                                      | Timer expires (`alarm()`)           |
| SIGPIPE   | 13            | Broken pipe                                                       | Write to pipe with no reader        |
| SIGUSR1   | 10            | User-defined signal 1                                             | Application-specific use            |
| SIGUSR2   | 12            | User-defined signal 2                                             | Application-specific use            |
| SIGHUP    | 1             | Hangup detected                                                   | Terminal closed                     |
| SIGQUIT   | 3             | Quit and dump core                                                | **Ctrl + \\**                       |
| SIGTSTP   | 20            | Terminal stop signal                                              | **Ctrl + Z**                        |


### SIGABRT
- Sent when a process calls `abort()`
- Default action: terminate process and generate a core dump
- Mainly used for debugging

### SIGALRM
- Generated when a real-time timer expires
- Timers set using `alarm()` or `setitimer()`
- Counts wall-clock (real) time

### SIGBUS
- Indicates a bus error
- Caused by invalid memory access
- Common example: accessing beyond an `mmap()`-mapped file

### SIGCHLD
- Sent to a parent process when a child terminates
- Also sent when a child is stopped or resumed
- Generated by the kernel

### SIGCLD
- Synonym for SIGCHLD

### SIGCONT
- Resumes a stopped process
- Ignored if the process is already running
- Can be caught to perform actions on resume

### SIGEMT
- Implementation-dependent hardware error
- On Linux, used only on Sun SPARC systems
- EMT stands for Emulator Trap

### SIGFPE
- Generated for arithmetic errors
- Examples include divide-by-zero and floating-point exceptions
- Behavior depends on CPU architecture and control registers

### SIGHUP
- Sent when a terminal hangup occurs
- Commonly used by daemons to reload configuration files
- Often sent using `kill -HUP`

### SIGILL
- Sent when a process executes an illegal instruction
- Usually caused by corrupted binaries or invalid opcodes

### SIGINFO
- On Linux, synonym for SIGPWR
- On BSD systems, generated using Ctrl + T to display process status

### SIGINT
- Sent when the user presses Ctrl + C
- Default action is to terminate the process

### SIGIO
- Generated when an I/O event occurs on a file descriptor
- Enabled using `fcntl()`
- Common with terminals and sockets

### SIGIOT
- On Linux, synonym for SIGABRT
- On some UNIX systems, indicates a hardware fault

### SIGKILL
- Forcefully terminates a process
- Cannot be caught, blocked, or ignored
- Should be used only as a last resort

### SIGLOST
- Exists but unused on Linux
- Historically related to NFS lock recovery failures

### SIGPIPE
- Generated when writing to a pipe, FIFO, or socket with no reader
- Common when the reading end is closed

### SIGPOLL
- Derived from System V
- Synonym for SIGIO on Linux

### SIGPROF
- Generated when a profiling timer expires
- Counts CPU time in both user mode and kernel mode

### SIGPWR
- Power failure signal
- Used with UPS systems to trigger a safe system shutdown

### SIGQUIT
- Sent when the user presses Ctrl + \
- Terminates the process and generates a core dump
- Useful for debugging stuck programs

### SIGSEGV
- Generated on invalid memory access
- Common causes include bad pointers and writing to read-only memory
- Known as segmentation fault

### SIGSTKFLT
- Defined but unused on Linux
- Documented as a stack fault on coprocessor

### SIGSTOP
- Stops a process immediately
- Cannot be caught, blocked, or ignored

### SIGSYS
- Generated when a process makes an invalid system call
- Occurs when the system call number is not valid

### SIGTERM
- Standard signal for graceful termination
- Default signal sent by `kill` and `killall`
- Applications should handle this signal properly

### SIGTRAP
- Used by debuggers for breakpoints
- Also used for system call tracing (e.g., `strace`)

### SIGTSTP
- Sent when the user presses Ctrl + Z
- Job-control stop signal

### SIGTTIN
- Sent to a background process when it tries to read from the terminal
- Stops the process by default

### SIGTTOU
- Sent to a background process when it tries to write to the terminal
- Effective when terminal output stop is enabled

### SIGUNUSED
- Signal name kept for backward compatibility
- On modern Linux systems, often synonymous with SIGSYS

### SIGURG
- Indicates urgent (out-of-band) data on a socket

### SIGUSR1
- User-defined signal
- Never generated by the kernel
- Used for inter-process communication and synchronization

### SIGUSR2
- Same purpose as SIGUSR1
- User-defined signal

### SIGVTALRM
- Generated when a virtual timer expires
- Counts only user-mode CPU time

### SIGWINCH
- Sent when the terminal window size changes
- Used by applications to redraw their output

### SIGXCPU
- Sent when a process exceeds its CPU time limit
- Controlled by RLIMIT_CPU

### SIGXFSZ
- Sent when a process exceeds its file size limit
- Controlled by RLIMIT_FSIZE

## Signals Internal Working
### Signal Generation:
- A signal is generated when an event occurs:
- Hardware exception (divide by zero, invalid memory access)
- User action (Ctrl+C sends SIGINT)
- Another process sends it via kill() or similar
- A timer expires
- A child process state changes

### Signal Pending:
When a signal is generated, the kernel marks it as "pending" for the target process. The signal isn't delivered immediately—it waits until the process is scheduled to run.

### Signal Delivery:
* When the process is next scheduled to run (or returns from kernel mode to user mode), the kernel checks for pending signals. If any exist:
  * The kernel checks the signal disposition (default, handler, or ignore)
  * If there's a custom handler, the kernel sets up the process's stack to call the handler
  * The process executes the handler in user mode
  * When the handler returns, the process resumes where it was interrupted

### Signal Masking:
Processes can temporarily block (mask) signals. Blocked signals remain pending but aren't delivered until unblocked. This allows critical sections of code to run without interruption.

The os stores imcoming signals for each process in a pending signal list/queue.

<img width="500" height="500" alt="image" src="https://github.com/user-attachments/assets/3fa2de5b-7744-4e51-a6a6-6fa1f0697038" />

So, here `SIGINT` (2) is blocked, and no other signals are pending.



